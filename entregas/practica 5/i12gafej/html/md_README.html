<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Detector de ataques DOS (Hashing con direccionamiento abierto)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Detector de ataques DOS (Hashing con direccionamiento abierto) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>*© F.J. Madrid Cuevas (<a href="#" onclick="location.href='mai'+'lto:'+'fjm'+'ad'+'rid'+'@u'+'co.'+'es'; return false;">fjmad<span style="display: none;">.nosp@m.</span>rid@<span style="display: none;">.nosp@m.</span>uco.e<span style="display: none;">.nosp@m.</span>s</a>)* <em>Estructuras de Datos. Grado de Ingeniería Informática</em> <em>Universidad de Córdoba. España</em></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Objetivos</h1>
<ul>
<li>Implementar una tabla hash con gestión de colisiones usando direccionamiento abierto.</li>
<li>Aprender a usar los tipos de entero con tamaño de bit fijo definidos en <code>&lt;cstdint&gt;</code>.</li>
<li>Aprender a usar la nueva forma de generación de números aleatorios con C++11 definidos en <code>&lt;random&gt;</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Descripción</h1>
<p>Un ataque “Denial of Service” (DOS) consiste en que el ordenador atacante (o ordenadores si es coordinado) inundan a un servidor (p. ej. web, email, dns …) con peticiones de acceso con tal velocidad que este servidor no puede atender a nadie más (legítimo o no) y en caso extremo hasta puede caer.</p>
<p>Normalmente los servidores informan al sistema operativo de los accesos anómalos utilizando alguna utilidad “Log” del sistema. Un detector de ataques DOS rastreará estos “Log” periódicamente buscando patrones de acceso anómalos y bloqueando (“ban”) las direcciones consideradas como maliciosas en el cortafuegos por lo que ya no accederán al servidor.</p>
<p>En esta práctica vamos a simular un detector de ataques DOS. El diseño del detector se muestra en los algoritmos 1 y 2.</p>
<p>El detector (algoritmo 2) analizará periódicamente (cada segundo) el Log del sistema (lo abstraemos como una secuencia de entradas “<code>&lt;tiempo&gt; &lt;dirección ip&gt;</code>”). Usaremos dos variables para definir la ventana temporal. La variable <code>first</code> indica la primera entrada del Log sin procesar y la variable <code>last</code> indica la entrada más antigua dentro de la ventana temporal.</p>
<p>En cada ciclo del algoritmo principal (<code>DOS_detector</code>) el detector analizará y avanzará la ventana temporal 1 minuto usando el algoritmo <code>update_counters</code>.</p>
<p>El algoritmo <code>update_counters</code> tiene dos pasos:</p>
<ul>
<li>El primero avanza el comienzo de la ventana temporal hasta el tiempo <code>System::now()</code> incrementando la variable <code>first</code> e incrementando el contador de accesos asociados a la <a class="el" href="structIP.html" title="Represent a IPv4 address.">IP</a> de cada nueva petición registrada en el Log. Además, se controla cuántas veces una misma dirección <a class="el" href="structIP.html" title="Represent a IPv4 address.">IP</a> ha realizado una petición al servidor en el último minuto. Si este número de peticiones supera un umbral especificado por el usuario (<code>max_acc</code>), se considerará esta dirección <a class="el" href="structIP.html" title="Represent a IPv4 address.">IP</a> como maliciosa y será bloqueada (<code><a class="el" href="system_8cpp.html#a5197d3ade7728875761eae04705d43d8" title="The Operating System.">System()</a>.ban_ip()</code>) en el cortafuegos.</li>
<li>El segundo paso del algoritmo, avanza el límite posterior de la ventana temporal de un minuto (<code>System::now()-60</code>) incrementando la variable <code>last</code> y descuenta los accesos de las IPs que han quedado fuera de la ventana temporal, ya que sólo nos interesa los accesos en el último minuto.</li>
</ul>
<p>El detector usará dos tablas hash: una para almacenar un contador de peticiones por <a class="el" href="structIP.html" title="Represent a IPv4 address.">IP</a> activa en la ventana temporal y otra para mantener las IPs que han sido bloqueadas junto con el tiempo en el que el bloqueo termina. El sistema se encargará (dentro de la función <code>System::sleep()</code>) de sacar de la tabla de IPs bloqueadas aquellas para las que el tiempo de bloqueo se haya cumplido.</p>
<div style="margin-left: auto;
            margin-right: auto;
            width: 80%;
            border: solid;"></div><div style="margin-left: auto;
            margin-right: auto;
            width: 80%;
            border: solid;"><b>Algoritmo 1</b></div><div style="margin-left: auto;
            margin-right: auto;
            width: 80%;
            border: solid;"><div class="fragment"><div class="line">Procedure DOS_detector(</div>
<div class="line">  log:Log,//Array of pairs &lt;Time, IP&gt;</div>
<div class="line">  max_acc:Integer)//Max. num. of acc.</div>
<div class="line">Var</div>
<div class="line">   first:Integer //First unprocessed line of log.</div>
<div class="line">   last:Integer //Last line of Log in current temporal window.</div>
<div class="line">   c:HashTable[IP,Integer] //Save a counter by active ip.</div>
<div class="line">Begin</div>
<div class="line">  first ← 0</div>
<div class="line">  last ← 0</div>
<div class="line">  While System::sleep(1) Do //sleep 1 second.</div>
<div class="line">      update_counters(log, first, last, c, max_acc)</div>
<div class="line">  End-While</div>
<div class="line">End.</div>
</div><!-- fragment --> </div><div style="margin-left: auto;
            margin-right: auto;
            width: 80%;
            border: solid;"></div><div style="margin-left: auto;
            margin-right: auto;
            width: 80%;
            border: solid;"><b>Algoritmo 2</b></div><div style="margin-left: auto;
            margin-right: auto;
            width: 80%;
            border: solid;"><div class="fragment"><div class="line">Procedure update_counters(</div>
<div class="line">  log:Log,//Array of pairs &lt;Time, IP&gt;</div>
<div class="line">  Var first:Integer,//First unprocessed line of log.</div>
<div class="line">  Var last:Integer, //Last line of Log in current temporal window.</div>
<div class="line">  Var c:HashTable[IP, Integer],//Save a counter by active ip.</div>
<div class="line">  max_acc:Integer //Max. num. of acc. allowed.</div>
<div class="line">)</div>
<div class="line">Begin</div>
<div class="line">  //update new accesses.</div>
<div class="line">  While log[first].time &lt; system::now() Do</div>
<div class="line">      increment_counter(log[first].ip, c)</div>
<div class="line">      If n_acc(log[first].ip, c) &gt;= max_acc Then</div>
<div class="line">        System::ban_ip(log[first].ip)</div>
<div class="line">      End-If</div>
<div class="line">      first ← first + 1</div>
<div class="line">  End-While</div>
<div class="line">  //remove old accesses.</div>
<div class="line">  While log[last].time &lt; System::now()-60 Do</div>
<div class="line">      decrement_counter(log[last].ip, c)</div>
<div class="line">      last ← last + 1</div>
<div class="line">  End-While</div>
<div class="line">End.</div>
</div><!-- fragment --> </div><h1><a class="anchor" id="autotoc_md3"></a>
Detalles de implementación</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Uso de enteros con un tamaño de bit fijo</h2>
<p>Para implementar la funciones <code>Ip2Int()</code> y la función hash se debe por un lado convertir una dirección IPv4 en un entero sin signo de al menos 32 bits y realizar las operaciones para hacer el “hashing” usando más de 32 bits para poder ser representadas.</p>
<p>Como el tamaño en bits de los tipos int, unsigned, long y unsigned long dependen de la arquitectura donde se compila y queremos realizar un código general, vamos a utilizar los tipos de enteros con tamaño fijo definidos en &lt;cstdint&gt; [1] como son std::uint8_t, std::uint32_t y std::uint64_t para asegurar un tamaño de bits apropiado.</p>
<p>Sin embargo, el estándar C++ no asegura que todas las arquitecturas puedan proporcionar estos tipos por lo tanto hay que comprobar esto al configurar el proyecto. En el fichero CMakeLists.txt se puede ver una forma de indicar que nuestro proyecto depende de que la arquitectura donde se compila proporciona el tipo std::uint64_t.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Sobre la generación de números aleatorios</h2>
<p>El estándar C++11 añade un nuevo paquete para generación de números aleatorios accesible al incluir el fichero de cabecera <code>#include &lt;random&gt;</code> [3].</p>
<p>Anteriormente se utilizaba la funciones <code>rand()</code> y <code>srand()</code>. El problema es que hay distintos algoritmos para generar números pseudo-aleatorios y la función <code>rand()</code> sólo implementa un de estos algoritmos. Además, "*estas funciones mantienen un estado interno que es global y no está protegido. Esto significa que las llamadas a rand() nunca son seguras en entornos multi hilo*" [4].</p>
<p>El estándar C++11 [3] proporciona un método para utilizar distintos algoritmos generadores de números pseudo-aleatorios, seguros en entornos multi-hilo. Además, el estándar también proporciona funciones para generar números aleatorios siguiendo las más conocidas distribuciones de probabilidad como: uniforme en rango flotante (<code>std::uniform_real_distribution&lt;&gt;</code>), uniforme en rango entero (<code>std::uniform_int_distribution&lt;&gt;</code>), normal, binomial, etc.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Sobre la simulación del sistema operativo</h2>
<p>El código base entregado usará un “singleton” [2] accesible con “System()” para abstraer algunas operaciones del sistema operativo como son: <code>time()</code>, <code>sleep()</code>, <code>ban_ip()</code> y <code>banned_ips()</code>.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Evaluación</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Superar todos los tests   </th><th class="markdownTableHeadLeft">Puntos    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_ip_utils tests_ip_utils</code>   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_hash_f tests_hash_function</code>   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_hash_f tests_hash_function_lp</code>   </td><td class="markdownTableBodyLeft">0,5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_hash_f tests_hash_function_rp</code>   </td><td class="markdownTableBodyLeft">0,5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_hash_f tests_hash_function_qp</code>   </td><td class="markdownTableBodyLeft">0,5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_hash_f tests_hash_function_dh</code>   </td><td class="markdownTableBodyLeft">0,5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>test_hash_table tests_hash_table</code>   </td><td class="markdownTableBodyLeft">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>test_dos_detector tests_dos_detector</code>   </td><td class="markdownTableBodyLeft">2   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md8"></a>
Referencias</h1>
<p>[1] <code>&lt;cstdint&gt;</code>: <a href="https://en.cppreference.com/w/cpp/header/cstdint">https://en.cppreference.com/w/cpp/header/cstdint</a> [2] Patrón de diseño OO "Singleton": <a href="https://es.wikipedia.org/wiki/Singleton">https://es.wikipedia.org/wiki/Singleton</a> [3] <code>&lt;random&gt;</code>: <a href="https://en.cppreference.com/w/cpp/numeric/random">https://en.cppreference.com/w/cpp/numeric/random</a> [4] Funciones que no son seguras en entornos multi hilo: <a href="https://developer.arm.com/documentation/dui0475/m/the-c-and-c&mdash;library-functions-reference/c-library-functions-that-are-not-thread-safe">https://developer.arm.com/documentation/dui0475/m/the-c-and-c&amp;mdash;library-functions-reference/c-library-functions-that-are-not-thread-safe</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
